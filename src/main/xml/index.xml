<book xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi='http://www.w3.org/2001/XInclude'
      role="homepage"
      version="5.2">
<info>
<title><inlinemediaobject role="narrow">
<imageobject>
<imagedata fileref="../website/img/xr.png"/>
</imageobject>
</inlinemediaobject>The XML Resolver Project<inlinemediaobject>
<imageobject role="margin">
<imagedata fileref="../website/img/xr.png"/>
</imageobject>
</inlinemediaobject></title>
<abstract>
<para>Welcome! This is the home page for a family of resolver projects,
including implementations in
<link xlink:href="https://github.com/xmlresolver/xmlresolver">Java</link>
and
<link xlink:href="https://github.com/xmlresolver/xmlresolvercs">C#</link>.
These implementations and related projects are hosted under the
<link xlink:href="https://github.com/xmlresolver">XML Resolver</link>
organization at
<link xlink:href="https://github.com/">GitHub</link>.</para>
<itemizedlist>
<listitem>
<para><link linkend="what">What is it?</link></para>
</listitem>
<listitem>
<para><link linkend="why">Why do I want it?</link></para>
</listitem>
<listitem>
<para><link linkend="getting">How do I get it?</link></para>
</listitem>
<listitem>
<para><link linkend="using">How do I use it?</link></para>
</listitem>
<listitem>
<para><link linkend="configuring">How do I configure it?</link></para>
</listitem>
<listitem>
<para><link linkend="config-settings">What can I configure?</link></para>
</listitem>
<listitem>
<para><link linkend="changelog">Change log</link></para>
</listitem>
</itemizedlist>
<important role="vernote">
<para>This is the documentation for <citetitle>XML Resolver</citetitle> version 6.x,
released in January, 2024. This version is not backwards compatible with version 5.x.
Documentation for the <link xlink:href="/legacy_v5/">legacy v5.x releases</link> is
still available.</para>
</important>
</abstract>
</info>

<chapter xml:id="what">
<title>What is a resolver?</title>

<para>An XML Resolver is an tool for mapping URIs to local resources.
The name comes from the fact that there are APIs to support this
mapping in most XML parsers and the underlying catalog format grew out
of an existing markup standard. In principle, it can be used in any environment
where it would be useful to remap URIs.</para>

<para>The web encourages us to name resources with URIs. This is
generally “a good thing,” but there are circumstances under which it’s
inconvenient. A canonical example is when you don’t have reliable
internet connectivity. Sometimes it’s useful in applications to return
a locally cached resource instead of the resource actually requested.
For example, it’s a significant feature of the web that you can
dereference the URI</para>

<programlisting>http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</programlisting>

<para>and find out that it’s the DTD for XHTML. It is not, however,
<emphasis>desireable</emphasis> that <emphasis>everyone</emphasis>
should <emphasis>always</emphasis> dereference that URI to get the
XHTML DTD. It hasn’t changed in more than a decade and there’s no
reason to believe it <emphasis>will  ever</emphasis> change again.</para>

<para>The same is true of resources located in repositories like Maven
and NuGet, where institutional policies dictate that once a resource
is published, it can never be updated in place.</para>

</chapter>

<chapter xml:id="why">
<title>Why use a resolver?</title>

<para>I chose the preceding DTD example with care. Even though DTDs
are no longer fashionable in many circles, it’s a popular, effectively
immutable resource served up by the W3C. The W3C web server gets
<emphasis>so many</emphasis> requests for the XHTML DTD that it sometimes goes
out of its way to make retrieving it painful.</para>

<para>You may have noticed that downloading resources (schemas, DTDs,
etc., not the specifications, generally) from the W3C is sometimes
very slow. This is a kind of rate limiting effect to save bandwidth.
It discourages developers from pounding on their servers. If you don’t
take the hint, they’ll even lock you out for a period of time.</para>

<para>Even if the servers you frequently access don’t discourage you
from repeatedly downloading the same resources, you (or your
customers!) may sometimes have limited connectivity.</para>

<para>Point being: there are lots of URIs which you can usefully cache
locally.</para>

<para>There are basically two approaches to local caching: you can
setup a proxy server and have it cache things for you, or you can use
<link xlink:href="https://xmlcatalogs.org">XML Catalogs</link>. I
don’t dispute there might be other approaches, but those are the two
common, obvious ones.</para>

<para>The advantage of the local caching proxy is that it’s automatic. It
caches the resources you request according to whatever criteria you
establish, it works transparently in the background. No muss, no fuss.
Well, except for the fact that you have to install and setup a local
caching proxy. You have to use it everywhere. You might have to chain
it together with your corporate caching proxy. You also have to
configure the criteria for local caching. I find its advantages are a
lot more theoretical than practical.</para>

<para>The XML Resolver project is about doing it with catalogs.</para>

<para>
<link xlink:href="https://xmlcatalogs.org">XML Catalogs</link>
are straightforward; you provide an XML document that has
mappings from identifiers that might appear in documents to local
resources that should be returned for those identifiers.</para>

<para>Here’s an example:</para>

<programlisting language="xml"><![CDATA[<catalog xmlns="urn:oasis:names:tc:entity:xmlns:xml:catalog">
  <system systemId="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
          uri="/share/dtds/xhtml1-strict.dtd"/>
</catalog>]]></programlisting>

<para>If you load that catalog, attempts to obtain the XHTML DTD from the W3C
will be satisfied by a local copy of the DTD obtained from the
<filename>/share/dtds/xhtml1-strict.dtd</filename>.</para>

<para>You can write catalogs that suit your resources, and they can be chained
together to work with and across multiple projects.</para>

</chapter>

<chapter xml:id="getting">
<info>
<title>Getting an XML Resolver</title>
</info>

<para>The XML Resolver is distributed in two ways: you can get it as a release
from <link xlink:href="https://github.com/xmlresolver/xmlresolver/releases">GitHub</link>,
or you can get it from Maven with coordinates like these:</para>

<programlisting language="xml"><![CDATA[<dependency>
  <groupId>org.xmlresolver</groupId>
  <artifactId>xmlresolver</artifactId>
  <version>]]><?resolver-version?><![CDATA[</version>
</dependency>

<dependency>
  <groupId>org.xmlresolver</groupId>
  <artifactId>xmlresolver</artifactId>
  <version>]]><?resolver-version?><![CDATA[</version>
  <classifier>data</classifier>
</dependency>]]></programlisting>

<para>Place the XML Resolver jar file on your classpath to use the resolver.
If you also place the “data” jar file on your classpath, you will automatically
get local resolution of a large number of open source schemas and DTDs.</para>

<para>Other distributions can also take advantage of this automatic
behavior by placing a catalog file at
<literal>org/xmlresolver/catalog.xml</literal> in the jar file. For example, the
<link xlink:href="https://github.com/docbook/docbook">DocBook schemas</link>
and
<link xlink:href="https://github.com/docbook/xslTNG">xslTNG</link> releases do this.
Simply placing those jar files in your classpath will make catalog resolution of
the standard URIs quick and efficient.
</para>

<section>
<title>What’s in the “data” jar?</title>

<para>The data artifact (a separate <code>.jar</code> file on Java, a separate assembly on C#)
contains the following resources and a catalog that maps to local copies of them stored
in the data artifact:</para>

<xi:include href="datalist.xml"/>

<para>The data artifact is maintained separately; for the most up-to-date information
about what it contains, see <link xlink:href="https://github.com/xmlresolver/xmlresolverdata"/>
for the Java release and
<link xlink:href="https://github.com/xmlresolver/xmlresolvercsdata"/> for the C# release.
</para>

</section>

</chapter>
<chapter xml:id="using">
<info>
<title>Using an XML Resolver</title>
</info>

<para>The simplest possible thing you can do is instantiate an instance of
<classname>org.xmlresolver.XMLResolver</classname> and use it to obtain a resolver
for each of the XML parsing APIs that you are using.</para>

<informaltable frame="all">
<tgroup cols="2" colsep="1" rowsep="1">
<thead>
<row>
<entry>Call this method:</entry>
<entry>To obtain:</entry>
</row>
</thead>
<tbody>
<row>
  <entry><methodname>getEntityResolver()</methodname></entry>
  <entry>A SAX1 <interfacename>org.xml.sax.EntityResolver</interfacename></entry>
</row>
<row>
  <entry><methodname>getEntityResolver2()</methodname></entry>
  <entry>A SAX2 <interfacename>org.xml.sax.ext.EntityResolver2</interfacename></entry>
</row>
<row>
  <entry><methodname>getURIResolver()</methodname></entry>
  <entry>A JAXP <interfacename>javax.xml.transform.URIResolver</interfacename></entry>
</row>
<row>
  <entry><methodname>getLSResourceResolver()</methodname></entry>
  <entry>A W3C DOM <interfacename>org.w3c.dom.ls.LSResourceResolver</interfacename></entry>
</row>
<row>
  <entry><methodname>getXMLResolver()</methodname></entry>
  <entry>A StAX <interfacename>javax.xml.stream.XMLResolver</interfacename></entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>Another simple integration point is to instantiate
<classname>org.xmlresolver.tools.ResolvingXMLReader</classname> as your XML parser.</para>

<section xml:id="programming">
<title>Programming with the resolver</title>
<para>If you want to take more complete programmatic control of the resolver,
instantiate a resolver configuration:</para>

<programlisting language="java"
><![CDATA[XMLResolverConfiguration config
  = new XMLResolverConfiguration(propertyFiles, catalogs);]]></programlisting>

<para>Set the features as you wish:</para>

<programlisting language="java"><![CDATA[config.setFeature(ResolverFeature.DEFAULT_LOGGER_LOG_LEVEL, "info");

if (validateCatalogs) {
    config.setFeature(ResolverFeature.CATALOG_LOADER_CLASS,
                      "org.xmlresolver.loaders.ValidatingXmlLoader");
}]]></programlisting>

<para>Then instantiate an XML Resolver:</para>

<programlisting language="java"><![CDATA[XMLResolver resolver = new XMLResolver(config);]]></programlisting>

<para>and use that resolver in your parsing and URI retrieval.</para>

<programlisting language="java"><![CDATA[myXmlReader.setEntityResolver(resolver.getEntityResolver2());]]></programlisting>

<para>For additional APIs, consult the <link xlink:href="javadoc/index.html">JavaDoc</link>.</para>
</section>

</chapter>

<chapter xml:id="configuring">
<info>
<title>Configuring an XML Resolver</title>
</info>

<para>The XML Resolver is available for both Java and .NET. By and
large, it works the same way in both environments and has similar
features. One area where differences are unavoidable is in
configuration because Java and .NET expose different mechanisms.</para>

<para>The Java XML Resolver classes use either Java system properties
or a standard Java properties file to establish an initial
environment.</para>

<para>On .NET, environment variables are used instead of system
properties and the properties file is a standard .NET configuration
file.</para>

<section xml:id="config-java">
<title>Configuring XML Resolver on Java</title>

<para>On Java, the resolver searches for a property file by looking in
the following places, in this order:</para>

<itemizedlist>
<listitem>
<para>The location identified by the <sysprop>xmlresolver.properties</sysprop> system property.
</para>
</listitem>
<listitem>
<para>The location identified by the <envar>XMLRESOLVER_PROPERTIES</envar> environment variable.
</para>
</listitem>
<listitem>
<para>A file named <filename>xmlresolver.properties</filename> on your classpath.
</para>
</listitem>
</itemizedlist>

<section xml:id="xmlresolver.properties">
<title>Example xmlresolver.properties file</title>

<para>An <filename>xmlresolver.properties</filename> file
might look like this:</para>

<programlisting># xmlresolver.properties

relative-catalogs=yes

# Always use semicolons in this list
catalogs=./catalog.xml;/Users/ndw/Documents/catalog.xml

prefer=public
allow-oasis-xml-catalog-pi=no
prefer-property-file=false</programlisting>
</section>
</section>

<section xml:id="config-net">
<title>Configuring XML Resolver on .NET</title>

<para>On .NET, the resolver uses the enviornment variable <envar>XMLRESOLVER_APPSETTINGS</envar>
to locate .NET properties file. The properties file can be either XML (in an
<code>XmlResolver</code> section) or JSON (in an <code>XmlResolver</code> object).</para>

<section xml:id="xmlresolver.config.xml">
<title>Example xmlresolver.config file</title>

<para>An <filename>xmlresolver.config</filename> file
might look like this:</para>

<programlisting language="xml"><![CDATA[<configuration>
  <xmlResolver relativeCatalogs="no"
               catalogs="./catalog.xml;/Users/userid/Documents/catalog.xml"
               prefer="public"
               allowOasisXmlCatalogPi="yes"
               preferPropertyFile="no"/>
</configuration>]]></programlisting>

<para>If JSON is more convenient, <!-- stranger things have happened -->
it might look like this:</para>

<programlisting language="json">{
  "XmlResolver": {
    "preferPublic": true,
    "relativeCatalogs": "false",
    "catalogs": "./catalog.xml;/Users/userid/Documents/catalog.xml",
    "prefer": "public",
    "allowOasisXmlCatalogPi": "yes",
    "preferPropertyFile": "no"
  }
}</programlisting>
</section>

</section>
</chapter>

<chapter xml:id="config-settings">
<title>What you can configure</title>

<para>This chapter lists all of the configurable settings in XML Resolver.
</para>

<?settings-toc?>

<section xml:id="xml.catalog.files">
<title>The initial list of catalog files</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.CATALOG_FILES</constant> (type: <type>List&lt;String&gt;</type>)</simpara>
</listitem>
<listitem><simpara>System property <sysprop>xml.catalog.files</sysprop></simpara></listitem>
<listitem><simpara>Property file property <fprop>catalogs</fprop></simpara></listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>Feature <constant>ResolverFeature.CATALOG_FILES</constant> (type: <type>List&lt;string&gt;</type>)</simpara>
</listitem>
<listitem><simpara>Environment variable <envar>XML_CATALOG_FILES</envar></simpara></listitem>
<listitem><simpara>Property file property <fprop>catalogs</fprop></simpara></listitem>
</itemizedlist>

<para>A semicolon-delimited list of catalog files. These are the catalog
files that are initially consulted for resolution. If no catalog files
are specified, by default the resolver will attempt to use a file
named <filename>catalog.xml</filename> in the current directory as a catalog.</para>

</section>
<section xml:id="xml.catalog.additions">
<title>A list of additional catalog files</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.CATALOG_ADDITIONS</constant> (type: <type>List&lt;String&gt;</type>)</simpara>
</listitem>
<listitem><simpara>System property <sysprop>xml.catalog.additions</sysprop></simpara></listitem>
<listitem><simpara>Property file property <fprop>catalog-additions</fprop></simpara></listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>Feature <constant>ResolverFeature.CATALOG_ADDITIONS</constant> (type: <type>List&lt;string&gt;</type>)</simpara>
</listitem>
<listitem><simpara>Environment variable <envar>XML_CATALOG_ADDITIONS</envar></simpara></listitem>
<listitem><simpara>Property file property <fprop>catalogAdditions</fprop></simpara></listitem>
</itemizedlist>

<para>A semicolon-delimited list of catalog files. This list is used in
addition to the initial list of catalog files.</para>

<para>If you attempt to use both a system property <emphasis>and</emphasis> a property from a
property file to create the initial list of catalog files, you’ll only
get one or the other. (See prefer-property-file.)</para>

<para>This property provides a way to add to the current list of files. For
example, suppose you use a global properties file to initialize the resolver, but
for a particular application you want to search <emphasis>additional</emphasis> catalogs.
You can specify them in the <sysprop>xml.catalog.additions</sysprop> system property and they’ll
be appended to the list instead of replacing the list entirely as setting
<sysprop>xml.catalog.files</sysprop> would.</para>

</section>

<section xml:id="xml.catalog.accessExternalDocument">
<title>Specify protocol(s) allowed for URI access</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.ACCESS_EXTERNAL_DOCUMENT</constant> (type: <type>String</type>)</simpara>
</listitem>
<listitem><simpara>System property <sysprop>xml.catalog.accessExternalDocument</sysprop></simpara></listitem>
<listitem><simpara>Property file property <fprop>access-external-document</fprop></simpara></listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>Feature <constant>ResolverFeature.ACCESS_EXTERNAL_DOCUMENT</constant> (type: <type>string</type>)</simpara>
</listitem>
<listitem><simpara>Environment variable <envar>XML_CATALOG_ACCESS_EXTERNAL_DOCUMENT</envar></simpara></listitem>
<listitem><simpara>Property file property <fprop>accessExternalDocument</fprop></simpara></listitem>
</itemizedlist>

<para>This feature restricts the protocols that are allowed during URI
resolution. If an attempt is made to resolve a document and the URI
for that document uses a protocol not listed in this feature, the
request is rejected. See JAXP 185.</para>

<para>The keyword “<literal>all</literal>” allows all protocols. An
empty string allows none.</para>

<para>The default value for this feature is “<literal>all</literal>”.</para>

</section>

<section xml:id="xml.catalog.accessExternalEntity">
<title>Specify protocol(s) allowed for entity access</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.ACCESS_EXTERNAL_ENTITY</constant> (type: <type>String</type>)</simpara>
</listitem>
<listitem><simpara>System property <sysprop>xml.catalog.accessExternalEntity</sysprop></simpara></listitem>
<listitem><simpara>Property file property <fprop>access-external-entity</fprop></simpara></listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>Feature <constant>ResolverFeature.ACCESS_EXTERNAL_ENTITY</constant> (type: <type>string</type>)</simpara>
</listitem>
<listitem><simpara>Environment variable <envar>XML_CATALOG_ACCESS_EXTERNAL_ENTITY</envar></simpara></listitem>
<listitem><simpara>Property file property <fprop>accessExternalEntity</fprop></simpara></listitem>
</itemizedlist>

<para>This feature restricts the protocols that are allowed during entity
resolution. If an attempt is made to resolve an entity and the URI
for that entity uses a protocol not listed in this feature, the
request is rejected. See JAXP 185.</para>

<para>The keyword “<literal>all</literal>” allows all protocols. An
empty string allows none.</para>

<para>The default value for this feature is “<literal>all</literal>”.</para>

</section>

<section xml:id="xml.assembly.catalogs">
<title>Catalogs to load from assemblies</title>

<itemizedlist role="java">
<listitem>
<simpara>This setting has no equivalent on Java.</simpara>
</listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>Feature <constant>ResolverFeature.ASSEMBLY_CATALOGS</constant> (type: <type>List&lt;string&gt;</type>)</simpara>
</listitem>
</itemizedlist>

<para>This setting can be used to load additional catalogs from other assemblies
linked into your application.</para>

<para>Starting in version 2.0.0, the assembly catalogs should be identified by their
<code>AssemblyName</code>, not by the name of the DLL as previously.</para>

</section>

<section xml:id="xml.data.assembly">
<title>Load the XmlResolverData assembly catalog?</title>

<itemizedlist role="java">
<listitem>
<simpara>This setting has no equivalent on Java.</simpara>
</listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>Feature <constant>ResolverFeature.USE_DATA_ASSEMBLY</constant> (type: <type>bool</type>)</simpara>
</listitem>
<listitem><simpara>Environment variable <envar>XML_CATALOG_USE_DATA_ASSEMBLY</envar></simpara></listitem>
<listitem><simpara>Property file property <fprop>useDataAssembly</fprop></simpara></listitem>
</itemizedlist>

<para>This setting, which defaults to <code>true</code>, tells the resolver that
it should always attempt to use the catalog in the
<filename>XmlResolverData.dll</filename> assembly. This assembly is distributed as
<link xlink:href="https://www.nuget.org/packages/XmlResolverData/">a
separate NuGet package</link> and includes a variety of common resources.</para>

<para>This setting has no effect unless you’ve linked that assembly into your application.
</para>
</section>

<section xml:id="xml.catalog.classpathCatalogs">
<title>Load catalogs from the classpath</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.CLASSPATH_CATALOGS</constant> (type: <type>Boolean</type>)</simpara>
</listitem>
<listitem><simpara>System property <sysprop>xml.catalog.classpathCatalogs</sysprop></simpara></listitem>
<listitem><simpara>Property file property <fprop>classpath-catalogs</fprop></simpara></listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>This setting has no equivalent on .NET</simpara>
</listitem>
</itemizedlist>

<para>Load catalog files from the classpath. If this property is true, the
resolver will search for all of the files named
<filename>org/xmlresolver/catalog.xml</filename> on the classpath and add each of them to the end
of the catalog list.</para>

</section>
<section xml:id="xml.catalog.prefer">
<title>Preference for public or system identifiers</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.PREFER_PUBLIC</constant> (type: <type>Boolean</type>)</simpara>
</listitem>
<listitem><simpara>System property <sysprop>xml.catalog.prefer</sysprop></simpara></listitem>
<listitem><simpara>Property file property <fprop>prefer</fprop></simpara></listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>Feature <constant>ResolverFeature.PREFER_PUBLIC</constant> (type: <type>bool</type>)</simpara>
</listitem>
<listitem><simpara>Environment variable <envar>XML_CATALOG_PREFER</envar></simpara></listitem>
<listitem><simpara>Property file property <fprop>prefer</fprop></simpara></listitem>
</itemizedlist>

<para>The initial prefer setting, either public or system.</para>

</section>
<section xml:id="xml.catalog.allowPI">
<title>Obey <tag class="pi">oasis-xml-catalog</tag> processing instruction</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.ALLOW_CATALOG_PI</constant> (type: <type>Boolean</type>)</simpara>
</listitem>
<listitem><simpara>System property <sysprop>xml.catalog.allowPI</sysprop></simpara></listitem>
<listitem><simpara>Property file property <fprop>allow-oasis-xml-catalog-pi</fprop></simpara></listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>Feature <constant>ResolverFeature.ALLOW_CATALOG_PI</constant> (type: <type>bool</type>)</simpara>
</listitem>
<listitem><simpara>Environment variable <envar>XML_CATALOG_ALLOW_PI</envar></simpara></listitem>
<listitem><simpara>Property file property <fprop>allowOasisXmlCatalogPi</fprop></simpara></listitem>
</itemizedlist>

<para>This setting allows you to toggle whether or not the resolver classes
obey the <literal>&lt;?oasis-xml-catalog?&gt;</literal> processing instruction.</para>

<para>If you never use the processing instruction, you can get a very tiny
performance improvement by disabling this feature. (If this feature is
enabled, the parser has to create a copy of the resolver configuration
for every parse.)</para>

</section>

<section xml:id="xml.catalog.alwaysResolve">
<title>Always resolve resources</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.ALWAYS_RESOLVE</constant> (type: <type>Boolean</type>)</simpara>
</listitem>
<listitem><simpara>System property <sysprop>xml.catalog.alwaysResolve</sysprop></simpara></listitem>
<listitem><simpara>Property file property <fprop>always-resolve</fprop></simpara></listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>This setting has no equivalent on .NET</simpara>
</listitem>
</itemizedlist>

<para>The standard contract for the Java resolver APIs is that they
return <code>null</code> if the resolver doesn’t find a match. But on
the modern web, lots of URIs redirect (from <code>http:</code> to
<code>https:</code> especially), and some parsers don’t follow
redirects. That causes the parse to fail in ways that may not be easy
for the user to fix.</para>

<para>Starting in version 5.0.0, the resolver will always resolve resources,
follow redirects, and return a stream. This deprives the parser of the option to try
something else, but means that redirects don’t cause the parse to file.</para>

<para>This feature is <emphasis>enabled</emphasis> by default. If you
set it to false, the resolver will return <code>null</code> if the
resource isn’t found in the catalog.</para>

<para>I don’t know of any parsers that try anything else after the
resolver has failed except loading the resource, so I expect this to
be an improvement for users. If your implementation wants to explicitly just
check the catalog, at the Java API level, you can use the
<code>CatalogManager</code> API. That’s the same API the
resolver classes use to locate resources in the catalog.</para>
</section>

<section xml:id="relative-catalogs">
<title>Support relative catalog paths</title>

<itemizedlist role="java">
<listitem><simpara>Property file property <fprop>relative-catalogs</fprop></simpara></listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem><simpara>Property file property <fprop>relativeCatalogs</fprop></simpara></listitem>
</itemizedlist>

<para>If <fprop>relative-catalogs</fprop> is true, relative filenames in the
<fprop>catalogs</fprop>
property list will be made absolute relative to the current working
directory; otherwise they will be made
absolute with respect to the base URI of the properties file from
which they came.</para>

<para>This setting has no effect on catalogs loaded from the
<sysprop>xml.catalogs.files</sysprop> system property which are always made absolute
with respect to the current working directory.</para>

</section>

<section xml:id="xml.catalog.fixWindowsSystemIdentifiers" role="since-4.4.0">
<title>Fix system identifiers on Windows.</title>

<para>This feature is new in XML Resolver 4.4.0.</para>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.FIX_WINDOWS_SYSTEM_IDENTIFIERS</constant>
(type: <type>Boolean</type>)</simpara>
</listitem>
<listitem><simpara>System property <sysprop>xml.catalog.fixWindowsSystemIdentifiers</sysprop></simpara></listitem>
<listitem><simpara>Property file property <fprop>fix-windows-system-identifiers</fprop></simpara></listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>Feature <constant>ResolverFeature.FIX_WINDOWS_SYSTEM_IDENTIFIERS</constant>
(type: <type>bool</type>)</simpara>
</listitem>
<listitem><simpara>Environment variable <envar>XML_CATALOG_FIX_WINDOWS_SYSTEM_IDENTIFIERS</envar></simpara></listitem>
<listitem><simpara>Property file property <fprop>fixWindowsSystemIdentifiers</fprop></simpara></listitem>
</itemizedlist>

<para>Windows uses the backslash (“\”) instead of the forward slash as
a path separator. The URI specification does not allow unescaped
backslashes to appear in URIs, but as a practical reality, many users
think of them as filenames and may simply copy filesystem paths as
system identifiers. On Windows, this will cause “URI syntax”
exceptions if an attempt is made to resolve them.</para>

<para>If <code>FIX_WINDOWS_SYSTEM_IDENTIFIERS</code> is true, and the
resolver is running on a Windows system, backslashes in system
identifiers are replaced with forward slashes before any resolution is
attempted.</para>

</section>

<section xml:id="xml.catalog.preferPropertyFile">
<title>Prefer property file values</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.PREFER_PROPERTY_FILE</constant> (type: <type>Boolean</type>)</simpara>
</listitem>
<listitem><simpara>System property <sysprop>xml.catalog.preferPropertyFile</sysprop></simpara></listitem>
<listitem><simpara>Property file property <fprop>prefer-property-file</fprop></simpara></listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>Feature <constant>ResolverFeature.PREFER_PROPERTY_FILE</constant> (type: <type>bool</type>)</simpara>
</listitem>
<listitem><simpara>Environment variable <envar>XML_CATALOG_PREFER_PROPERTY_FILE</envar></simpara></listitem>
<listitem><simpara>Property file property <fprop>preferPropertyFile</fprop></simpara></listitem>
</itemizedlist>

<para>Prefer properties from the properties file.
If a property file is loaded to configure the resolver and one of the properties in that
file is also specified as a system property, the system property takes precedence.
If you’d prefer to have the property file take precedence (as was the case in some
earlier versions), set the “prefer property file” property to true.</para>

</section>

<section xml:id="xml.catalog.saxParserFactoryClass">
<title>The SAX parser factory class</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.SAXPARSERFACTORY_CLASS</constant> (type: <type>String</type>)</simpara>
</listitem>
<listitem><simpara>System property <sysprop>xml.catalog.saxParserFactoryClass</sysprop></simpara></listitem>
<listitem><simpara>Property file property <fprop>saxparserfactory-class</fprop></simpara></listitem>
</itemizedlist>
<itemizedlist role="net">
<listitem>
<simpara>This setting has no equivalent on .NET</simpara>
</listitem>
</itemizedlist>

<para>By default, parsers are created with the
<link linkend="xmlreader_supplier">XMLREADER_SUPPLIER</link>.</para>

<para>This feature and the
<link linkend="xmlreader_supplier">XMLREADER_SUPPLIER</link> are different
mechanisms for configuring the same underlying feature: how does the
resolver get an XML parser if it needs one? (For example, for the <code>ResolvingXMLFilter</code> and
<code>ResolvingXMLReader</code> classes.)</para>

<para>The <code>SAXPARSERFACTORY_CLASS</code> is initially
<code>null</code> and the <code>XMLREADER_SUPPLIER</code> is used. The
purpose of the <code>SAXPARSERFACTORY_CLASS</code> is to allow the
factory to be configured with a property since the
<code>XMLREADER_SUPPLIER</code> cannot.</para>

<para>If a <code>SAXPARSERFACTORY_CLASS</code> is specified, it will
be used in favor of the default <code>XMLREADER_SUPPLIER.</code> If an
<code>XMLREADER_SUPPLIER</code> is explicitly set after the
configuration is initialized, it will set this feature to
<code>null</code> and take precedence.</para>
</section>

<section xml:id="xml.catalog.uriForSystem">
<title>Use URI entries for system resolution</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.URI_FOR_SYSTEM</constant> (type: <type>Boolean</type>)</simpara>
</listitem>
<listitem><simpara>System property <sysprop>xml.catalog.uriForSystem</sysprop></simpara></listitem>
<listitem><simpara>Property file property <fprop>uri-for-system</fprop></simpara></listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>Feature <constant>ResolverFeature.URI_FOR_SYSTEM</constant> (type: <type>bool</type>)</simpara>
</listitem>
<listitem><simpara>Environment variable <envar>XML_CATALOG_URI_FOR_SYSTEM</envar></simpara></listitem>
<listitem><simpara>Property file property <fprop>uriForSystem</fprop></simpara></listitem>
</itemizedlist>

<para>Ignore the distinction between system identifiers and URIs.
The distinction between external identifiers (the public and system identifiers that
are used in DTDs) and general URIs (as might be used to load a RELAX NG Grammar or XML Schema,
for example), is not supported uniformly by the parser APIs.
The Xerces XML Schema implementation, for example, users the
<methodname role="org.xml.sax.EntityResolver">resolveEntity</methodname> API to load
XML Schema imports.</para>

<para>Ordinarily, system identifier resolution interrogates the <tag>system</tag> and <tag>public</tag> entries (and their
related entries), but not the <tag>uri</tag> entries. If this property is true, the resolver will attempt
to resolve system identifiers with <tag>uri</tag> entries (<emphasis>after</emphasis>
attempting to resolve them with the
system and public entries.</para>

</section>
<section xml:id="xml.catalog.mergeHttps">
<title>Merge http: and https: URI schemes</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.MERGE_HTTPS</constant> (type: <type>Boolean</type>)</simpara>
</listitem>
<listitem><simpara>System property <sysprop>xml.catalog.mergeHttps</sysprop></simpara></listitem>
<listitem><simpara>Property file property <fprop>merge-https</fprop></simpara></listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>Feature <constant>ResolverFeature.MERGE_HTTPS</constant> (type: <type>bool</type>)</simpara>
</listitem>
<listitem><simpara>Environment variable <envar>XML_CATALOG_MERGE_HTTPS</envar></simpara></listitem>
<listitem><simpara>Property file property <fprop>mergeHttps</fprop></simpara></listitem>
</itemizedlist>

<para>Treat http: and https: URIs as equivalent for the purpose of resolution. The web used to
be served over http: and many existing catalog files contain http: system identifiers.
Today, the web is largely served over https: and many documents contain https: system
identifiers. If this property is true, that distinction will be ignored during catalog lookup,
<uri>http://example.com/sample.dtd</uri> will match <uri>https://example.com/sample.dtd</uri>.</para>

<para>Note: this has *no effect* on the URIs returned by the resolver or retrieved over the web.
It only effects catalog lookup for system identifiers and URIs.</para>

</section>
<section xml:id="xml.catalog.maskJarUris">
<title>Mask jar URIs</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.MASK_JAR_URIS</constant> (type: <type>Boolean</type>)</simpara>
</listitem>
<listitem><simpara>System property <sysprop>xml.catalog.maskJarUris</sysprop></simpara></listitem>
<listitem><simpara>Property file property <fprop>mask-jar-uris</fprop></simpara></listitem>
</itemizedlist>

<!--
<itemizedlist role="net">
<listitem>
<simpara>Feature <constant>ResolverFeature.MASK_PACK_URIS</constant> (type: <type>bool</type>)</simpara>
</listitem>
<listitem><simpara>Environment variable <envar>XML_CATALOG_MASK_PACK_URIS</envar></simpara></listitem>
<listitem><simpara>Property file property <fprop>maskPackUris</fprop></simpara></listitem>
</itemizedlist>
-->
<itemizedlist role="net">
<listitem>
<simpara>This setting has no equivalent on .NET</simpara>
</listitem>
</itemizedlist>

<para>Don’t return jar: or classpath: URIs. Most entity resolver APIs are defined such that if
resolution succeeds, the base URI of the resource returned is the base URI of the actual,
local resource. This can greatly simplify things because subsequent relative URIs can be
resolved against the local resource directly.</para>

<para>However, the Java URI class does not treat jar: or classpath: URI schemes as hierarchical,
so any subsequent attempts to resolve relative URIs will fail. If this property is true,
the local resource will be returned but the URI will be left unchanged. That may require a
more complete catalog, but it will avoid a situation which is guaranteed to fail.</para>

<sidebar>
<para>On .NET, a similar feature could be imagined for “pack:” scheme URIs, but in
practice, the way the <classname>System.XmlResolver</classname> works, it wouldn’t
serve any useful purpose.
</para>
</sidebar>

</section>
<section xml:id="xml.catalog.catalogLoaderClass">
<title>Catalog loader class</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.CATALOG_LOADER_CLASS</constant> (type: <type>String</type>)</simpara>
</listitem>
<listitem><simpara>System property <sysprop>xml.catalog.catalogLoaderClass</sysprop></simpara></listitem>
<listitem><simpara>Property file property <fprop>catalog-loader-class</fprop></simpara></listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>Feature <constant>ResolverFeature.CATALOG_LOADER_CLASS</constant> (type: <type>string</type>)</simpara>
</listitem>
<listitem><simpara>Environment variable <envar>XML_CATALOG_LOADER_CLASS</envar></simpara></listitem>
<listitem><simpara>Property file property <fprop>catalogLoaderClass</fprop></simpara></listitem>
</itemizedlist>

<para>Specify the catalog loader class. The default catalog loader ignores
any errors encountered when loading catalogs. This is convenient for
production use, but can be frustrating because it may not be obvious
when resolution fails, especially if your internet connection is fast.
A typo in a catalog file can easily go unnoticed.</para>

<para>If the value <classname>org.xmlresolver.loaders.ValidatingXmlLoader</classname> is specified
for this property, catalog files will be validated when they are
loaded and the resolver will throw an exception for any validity
errors encountered.</para>

<para>The validating loader depends on having version 20181222 of
<link
xlink:href="https://search.maven.org/artifact/org.relaxng/jing">Jing</link>
on your classpath. (This is an optional dependency in the Maven
distribution of the resolver, so you may have to add it by hand.)</para>

</section>
<section xml:id="xml.catalog.parseRddl">
<title>Parse RDDL documents</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.PARSE_RDDL</constant> (type: <type>Boolean</type>)</simpara>
</listitem>
<listitem><simpara>System property <sysprop>xml.catalog.parseRddl</sysprop></simpara></listitem>
<listitem><simpara>Property file property <fprop>parse-rddl</fprop></simpara></listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>Feature <constant>ResolverFeature.PARSE_RDDL</constant> (type: <type>bool</type>)</simpara>
</listitem>
<listitem><simpara>Environment variable <envar>XML_CATALOG_PARSE_RDDL</envar></simpara></listitem>
<listitem><simpara>Property file property <fprop>parseRddl</fprop></simpara></listitem>
</itemizedlist>

<para>Attempt to resolve RDDL resources in namespace URI lookup. If the
namespace resolver is used, if a nature and purpose are specified, and
if the resource returned is an HTML document, the resolver will
attempt to find the RDDL resource description for the requested
namespace and resolve that URI.</para>

<para>For example, the following API call will return the XML Schema for XML:</para>

<programlisting language="java">resolveNamespaceURI("http://www.w3.org/XML/1998/namespace",
                    "http://www.w3.org/2001/XMLSchema",
                    "http://www.rddl.org/purposes#schema-validation");</programlisting>

<para>Attempting to resolve RDDL resources requires extra processing. If you
know it will never succeed you can disable it by setting this property
to false.</para>

</section>
<section xml:id="classloader">
<title>Specify an alternate class loader</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.CLASSLOADER</constant> (type: <type>ClassLoader</type>)</simpara>
</listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>This setting has no equivalent on .NET</simpara>
</listitem>
</itemizedlist>

<para>If you are using the resolver in an environment where the default class
loader (<code>getClass().getCatalogLoader()</code>) will not return useful
class loader, you can specify an alternate loader with this feature.
</para>
</section>

<section xml:id="xmlreader_supplier">
<title>Configure the XML Reader</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.XMLREADER_SUPPLIER</constant>
(type: <type>Supplier&lt;XMLReader&gt;</type>)</simpara>
</listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>This setting has no equivalent on .NET</simpara>
</listitem>
</itemizedlist>

<para>The default supplier is obtained with <code>SAXParserFactory.newInstance()</code> and
the global mechanisms that it uses.</para>

<para>This feature and the <link linkend="xml.catalog.saxParserFactoryClass">SAXPARSERFACTORY_CLASS</link>
are different mechanisms for
configuring the same underlying feature: how does the resolver get an XML parser if it needs one?
(For example, for the <code>ResolvingXMLFilter</code> and
<code>ResolvingXMLReader</code> classes.)
</para>

<para>The
<link linkend="xml.catalog.saxParserFactoryClass">SAXPARSERFACTORY_CLASS</link>
is initially <code>null</code> and the <code>XMLREADER_SUPPLIER</code>
is used. The purpose of the <code>SAXPARSERFACTORY_CLASS</code> is to
allow the factory to be configured with a property since the
<code>XMLREADER_SUPPLIER</code> cannot.</para>

<para>If a <code>SAXPARSERFACTORY_CLASS</code> is specified, it will be used in favor of the default
<code>XMLREADER_SUPPLIER.</code> If an <code>XMLREADER_SUPPLIER</code> is explicitly set after the
configuration is initialized, it will set this feature to <code>null</code> and take precedence.</para>
</section>

<section xml:id="xml.catalog.throwUriExceptions">
<title>Throw URI exceptions?</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.THROW_URI_EXCEPTIONS</constant>
(type: <type>Boolean</type>)</simpara>
</listitem>
<listitem><simpara>System property <sysprop>xml.catalog.throwUriExceptions</sysprop></simpara></listitem>
<listitem><simpara>Property file property <fprop>throw-uri-exceptions</fprop></simpara></listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>This setting has no equivalent on .NET</simpara>
</listitem>
</itemizedlist>

<para>If this setting is true, errors in URIs that raise illegal argument exceptions,
malformed URI exceptions, or URI syntax exceptions will be thrown. If it’s false,
<code>null</code> is returned and the exception is ignored.</para>
</section>

<section xml:id="xml.catalog.archivedCatalogs" role="since-3.1.0">
<title>Support catalog files in ZIP archives</title>

<para>This feature is new in XML Resolver 3.1.0.</para>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.ARCHIVED_CATALOGS</constant> (type: <type>Boolean</type>)</simpara>
</listitem>
<listitem><simpara>System property <sysprop>xml.catalog.archivedCatalogs</sysprop></simpara></listitem>
<listitem><simpara>Property file property <fprop>archived-catalogs</fprop></simpara></listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>Feature <constant>ResolverFeature.ARCHIVED_CATALOGS</constant> (type: <type>bool</type>)</simpara>
</listitem>
<listitem><simpara>Environment variable <envar>XML_CATALOG_ARCHIVED_CATALOGS</envar></simpara></listitem>
<listitem><simpara>Property file property <fprop>archivedCatalogs</fprop></simpara></listitem>
</itemizedlist>

<para>If archived catalogs are allowed, then you can place ZIP files of resources
directly on the catalog path. The resolver will search inside the ZIP file for a catalog
(<code>/org/xmlresolver/catalog.xml</code> or <code>/catalog.xml</code>) to use.</para>

</section>
<section xml:id="catalogmanager">
<title>Access the underlying catalog manager</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.CATALOG_MANAGER</constant> (type: <type>CatalogManager</type>)</simpara>
</listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>Feature <constant>ResolverFeature.CATALOG_MANAGER</constant> (type: <type>CatalogManager</type>)</simpara>
</listitem>
</itemizedlist>

<para>The <classname role="org.xmlresolver">CatalogManager</classname> class provides
some lower-level methods for mapping to URIs without returning sources of any kind.
</para>
</section>

<section xml:id="logging">
<title>Logging</title>

<para>There are two options to control logging: the class used to perform logging
and the logging level desired.</para>

<para>These settings only apply to Java. On .NET, the <link
xlink:href="https://www.nuget.org/packages/NLog">NLog</link> package
is used for logging.</para>

<section xml:id="xml.catalog.resolverLoggerClass">
<title>The logger class</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.RESOLVER_LOGGER_CLASS</constant> (type: <type>String</type>)</simpara>
</listitem>
<listitem><simpara>System property <sysprop>xml.catalog.resolverLoggerClass</sysprop></simpara></listitem>
<listitem><simpara>Property file property <fprop>resolver-logger-class</fprop></simpara></listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>This setting has no equivalent on .NET</simpara>
</listitem>
</itemizedlist>

<para>The default logger class (<classname>org.xmlresolver.logging.DefaultLogger</classname>)
simply writes messages to standard error. For many applications, this is sufficient and
requires no additional configuration.</para>

<para>An alternate logger class (<classname>org.xmlresolver.logging.SystemLogger</classname>)
can easily be swapped in for environments where writing to standard error is inappropriate
or where more control is desired. If the system logger is used, it uses the 
<link xlink:href="http://www.slf4j.org/">SLF4J</link> API to do logging. You must configure
your environment with an appropriate logging backend.</para>

<para>A third option, available only at the API level, is to instantiate the
<classname>org.xmlresolver.logging.SystemLogger</classname> yourself and pass in the
<classname>java.util.logging.Logger</classname> class that you would like it to use.
</para>
</section>

<section xml:id="xml.catalog.defaultLoggerLogLevel">
<title>The logging level</title>

<itemizedlist role="java">
<listitem>
<simpara>Feature <constant>ResolverFeature.DEFAULT_LOGGER_LOG_LEVEL</constant> (type: <type>String</type>)</simpara>
</listitem>
<listitem><simpara>System property <sysprop>xml.catalog.defaultLoggerLogLevel</sysprop></simpara></listitem>
<listitem><simpara>Property file property <fprop>default-logger-log-level</fprop></simpara></listitem>
</itemizedlist>

<itemizedlist role="net">
<listitem>
<simpara>This setting has no equivalent on .NET</simpara>
</listitem>
</itemizedlist>

<para>As a convenience, the resolver categorizes log messages and
allows you to change the logging level for categories
selectively.</para>

<para>The log categories aren’t as fine grained as the class hierarchy.
There are five categories:</para>

<variablelist>
<varlistentry><term><literal>request</literal></term>
<listitem>
<para>Information related to the request.
</para>
</listitem>
</varlistentry>
<varlistentry><term><literal>response</literal></term>
<listitem>
<para>Information related to the response.
</para>
</listitem>
</varlistentry>
<varlistentry><term><literal>config</literal></term>
<listitem>
<para>Information related to configuration.
</para>
</listitem>
</varlistentry>
<varlistentry><term><literal>warning</literal></term>
<listitem>
<para>Reported warnings.
</para>
</listitem>
</varlistentry>
<varlistentry><term><literal>error</literal></term>
<listitem>
<para>Reported errors.
</para>
</listitem>
</varlistentry>
</variablelist>

<para>Any of these categories can be reported as “debug”, “info”, or
“warn” logging messages. This is configured with the system property
<sysprop>xml.catalog.logging</sysprop>. That property is interpreted as a comma
delimited list of <replaceable>category</replaceable>:<replaceable>level</replaceable>
pairs: for example, <code>request:warn,response:info</code>, would log request
messages as warnings and response messages as info.</para>

<para>If you prefer to specify this in a configuration file, use the
<fprop>catalog-logging</fprop> property. Note, however, that this
setting only applies if the system property is not set. (Because the
logging class doesn’t have access to the resolver configuration, it
can’t apply the usual defaulting rules.)</para>
</section>
</section>
</chapter>

<chapter xml:id="changelog">
<title>Change log</title>

<para>This chapter documents the significant changes in each release.</para>

<para>At the time of this writing, the 6.x release is still in testing.</para>

<revhistory>
<?db revhistory-style="list"?>
<revision>
<revnumber>6.0.8</revnumber>
<date>2024-08-07</date>
<revdescription>
<para>This release restores the <code>NamespaceResolver</code> API. This API is
deprecated, but improves backwards compatibility with version 5.x.
</para>
</revdescription>
</revision>
<revnumber>6.0.7</revnumber>
<date>2024-08-07</date>
<revdescription>
<para>This release removes two dependencies: the SLF4J API and the
Apache HTTP Client API. This has no user-visible changes in the API, but makes
version 6.x of the resolver a drop-in replacement for version 5.x in most cases.</para>
</revdescription>
</revision>
<revision>
<revnumber>6.0.6</revnumber>
<date>2024-08-06</date>
<revdescription>
<para>The following changes are included:</para>
<variablelist>
<varlistentry>
<term>Improvements to support for UNC paths</term>
<listitem>
<para>Documents and catalogs that use Windows UNC paths are better supported
if the <link linkend="xml.catalog.fixWindowsSystemIdentifiers">FIX_WINDOWS_SYSTEM_IDENTIFIERS</link>
feature is enabled.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Support for Java 21</term>
<listitem>
<para>The build still produces class (and jar) files that will work with any
version of Java back to Java 8. However, the build itself now uses Java 21.
This closes <link xlink:href="https://github.com/xmlresolver/xmlresolver/issues/173">issue 173</link>.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Refactor the SAX entity resolvers</term>
<listitem>
<para>The SAX <code>EntityResolver</code> and <code>EntityResolver2</code> interfaces
are now implemented on separate objects. 
This closes <link xlink:href="https://github.com/xmlresolver/xmlresolver/issues/183">issue 183</link>.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Fix namespace-based lookup in the DOM</term>
<listitem>
<para>The <code>LSResourceAdapter</code> API used when resolving documents
for the DOM did not correctly handle XML Schema validation. It was failing
to lookup based on the namespace.
This closes <link xlink:href="https://github.com/xmlresolver/xmlresolver/issues/180">issue 180</link>.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Improved support for concurrency</term>
<listitem>
<para>The catalog lookup code was not sufficiently careful about multi-threaded
access. My thanks to <link xlink:href="https://github.com/JFK-DXML">JFK-DXML</link> for
the patch.
This closes <link xlink:href="https://github.com/xmlresolver/xmlresolver/issues/182">issue 182</link>.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Reworked the FIX_WINDOWS_SYSTEM_IDENTIFIERS feature</term>
<listitem>
<para>This feature now applies irrespective of platform. This will enable Windows
documents and catalogs to work correctly even on non-Windows systems.
This closes <link xlink:href="https://github.com/xmlresolver/xmlresolver/issues/184">issue 184</link>.
</para>
</listitem>
</varlistentry>
</variablelist>

<para>A number of smaller issues (testing and build system issues and issues not
expected to be user visible) have also been corrected. See the commit log for more details.
</para>
</revdescription>
</revision>
<revision>
<revnumber>6.0.5</revnumber>
<date>2024-07-22</date>
<revdescription>
<para>Apparently version 6.0.5 was never released.</para>
</revdescription>
</revision>
</revhistory>
</chapter>

<chapter xml:id="seealso">
<title>See also</title>

<itemizedlist role="java">
<listitem>
<para>Absent more complete information here, most of
<link xlink:href="https://xerces.apache.org/xml-commons/components/resolver/resolver-article.html">XML
Entity and URI Resolvers</link> is still relevant.</para>
</listitem>
<listitem>
<para><link xlink:href="https://xmlcatalogs.org">XML Catalogs</link>
</para>
</listitem>
</itemizedlist>

</chapter>

<index xml:id="system-properties-index" type="sysprop">
<title>System properties index</title>
</index>

<index xml:id="property-file-properties-index" type="fprop">
<title>File properties index</title>
</index>

<index xml:id="envar-index" type="envar">
<title>Environment variables index</title>
</index>

<index xml:id="constant-index" type="constant">
<title>Constants index</title>
</index>

<index xml:id="api-index" type="code">
<title>API index</title>
<para>This index only includes the interface items mentioned in the
text. For additional APIs, consult the <link
xlink:href="javadoc/index.html">JavaDoc</link>.
</para>
</index>

</book>
