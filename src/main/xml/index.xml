<book xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi='http://www.w3.org/2001/XInclude'
      role="homepage"
      version="5.2">
<info>
<title><inlinemediaobject role="narrow">
<imageobject>
<imagedata fileref="../website/img/xr.png"/>
</imageobject>
</inlinemediaobject>The XML Resolver Project<inlinemediaobject>
<imageobject role="margin">
<imagedata fileref="../website/img/xr.png"/>
</imageobject>
</inlinemediaobject></title>
<abstract>
<para>Welcome! This is the home page for a family of resolver projects,
including implementations in
<link xlink:href="https://github.com/xmlresolver/xmlresolver">Java</link>
and
<link xlink:href="https://github.com/xmlresolver/xmlresolvercs">C#</link>.
These implementations and related projects are hosted under the
<link xlink:href="https://github.com/xmlresolver">XML Resolver</link>
organization at
<link xlink:href="https://github.com/">GitHub</link>.</para>
<itemizedlist>
<listitem>
<para><link linkend="what">What is it?</link></para>
</listitem>
<listitem>
<para><link linkend="why">Why do I want it?</link></para>
</listitem>
<listitem>
<para><link linkend="getting">How do I get it?</link></para>
</listitem>
<listitem>
<para><link linkend="using">How do I use it?</link></para>
</listitem>
<listitem>
<para><link linkend="configuring">How do I configure it?</link></para>
</listitem>
<listitem>
<para><link linkend="config-settings">What can I configure?</link></para>
</listitem>
<listitem>
<para><link linkend="changelog">Change log</link></para>
</listitem>
</itemizedlist>
<important role="vernote">
<para>This is the documentation for <citetitle>XML Resolver</citetitle> version 6.x,
released in January, 2024. This version is not backwards compatible with version 5.x.
Documentation for the <link xlink:href="/legacy_v5/">legacy v5.x releases</link> is
still available.</para>
</important>
</abstract>
</info>

<chapter xml:id="what">
<title>What is a resolver?</title>

<para>An XML Resolver is an tool for mapping URIs to local resources.
The name comes from the fact that there are APIs to support this
mapping in most XML parsers and the underlying catalog format grew out
of an existing markup standard. In principle, it can be used in any environment
where it would be useful to remap URIs.</para>

<para>The web encourages us to name resources with URIs. This is
generally “a good thing,” but there are circumstances under which it’s
inconvenient. A canonical example is when you don’t have reliable
internet connectivity. Sometimes it’s useful in applications to return
a locally cached resource instead of the resource actually requested.
For example, it’s a significant feature of the web that you can
dereference the URI</para>

<programlisting>http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</programlisting>

<para>and find out that it’s the DTD for XHTML. It is not, however,
<emphasis>desireable</emphasis> that <emphasis>everyone</emphasis>
should <emphasis>always</emphasis> dereference that URI to get the
XHTML DTD. It hasn’t changed in more than a decade and there’s no
reason to believe it <emphasis>will  ever</emphasis> change again.</para>

<para>The same is true of resources located in repositories like Maven
and NuGet, where institutional policies dictate that once a resource
is published, it can never be updated in place.</para>

</chapter>

<chapter xml:id="why">
<title>Why use a resolver?</title>

<para>I chose the preceding DTD example with care. Even though DTDs
are no longer fashionable in many circles, it’s a popular, effectively
immutable resource served up by the W3C. The W3C web server gets
<emphasis>so many</emphasis> requests for the XHTML DTD that it sometimes goes
out of its way to make retrieving it painful.</para>

<para>You may have noticed that downloading resources (schemas, DTDs,
etc., not the specifications, generally) from the W3C is sometimes
very slow. This is a kind of rate limiting effect to save bandwidth.
It discourages developers from pounding on their servers. If you don’t
take the hint, they’ll even lock you out for a period of time.</para>

<para>Even if the servers you frequently access don’t discourage you
from repeatedly downloading the same resources, you (or your
customers!) may sometimes have limited connectivity.</para>

<para>Point being: there are lots of URIs which you can usefully cache
locally.</para>

<para>There are basically two approaches to local caching: you can
setup a proxy server and have it cache things for you, or you can use
<link xlink:href="https://xmlcatalogs.org">XML Catalogs</link>. I
don’t dispute there might be other approaches, but those are the two
common, obvious ones.</para>

<para>The advantage of the local caching proxy is that it’s automatic. It
caches the resources you request according to whatever criteria you
establish, it works transparently in the background. No muss, no fuss.
Well, except for the fact that you have to install and setup a local
caching proxy. You have to use it everywhere. You might have to chain
it together with your corporate caching proxy. You also have to
configure the criteria for local caching. I find its advantages are a
lot more theoretical than practical.</para>

<para>The XML Resolver project is about doing it with catalogs.</para>

<para>
<link xlink:href="https://xmlcatalogs.org">XML Catalogs</link>
are straightforward; you provide an XML document that has
mappings from identifiers that might appear in documents to local
resources that should be returned for those identifiers.</para>

<para>Here’s an example:</para>

<programlisting language="xml"><![CDATA[<catalog xmlns="urn:oasis:names:tc:entity:xmlns:xml:catalog">
  <system systemId="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
          uri="/share/dtds/xhtml1-strict.dtd"/>
</catalog>]]></programlisting>

<para>If you load that catalog, attempts to obtain the XHTML DTD from the W3C
will be satisfied by a local copy of the DTD obtained from the
<filename>/share/dtds/xhtml1-strict.dtd</filename>.</para>

<para>You can write catalogs that suit your resources, and they can be chained
together to work with and across multiple projects.</para>

</chapter>

<chapter xml:id="getting">
<info>
<title>Getting an XML Resolver</title>
</info>

<para>The XML Resolver is distributed in two ways: you can get it as a release
from <link xlink:href="https://github.com/xmlresolver/xmlresolver/releases">GitHub</link>,
or you can get it from Maven with coordinates like these:</para>

<programlisting language="xml"><![CDATA[<dependency>
  <groupId>org.xmlresolver</groupId>
  <artifactId>xmlresolver</artifactId>
  <version>]]><?resolver-version?><![CDATA[</version>
</dependency>

<dependency>
  <groupId>org.xmlresolver</groupId>
  <artifactId>xmlresolver</artifactId>
  <version>]]><?resolver-version?><![CDATA[</version>
  <classifier>data</classifier>
</dependency>]]></programlisting>

<para>Place the XML Resolver jar file on your classpath to use the resolver.
If you also place the “data” jar file on your classpath, you will automatically
get local resolution of a large number of open source schemas and DTDs.</para>

<para>Other distributions can also take advantage of this automatic
behavior by placing a catalog file at
<literal>org/xmlresolver/catalog.xml</literal> in the jar file. For example, the
<link xlink:href="https://github.com/docbook/docbook">DocBook schemas</link>
and
<link xlink:href="https://github.com/docbook/xslTNG">xslTNG</link> releases do this.
Simply placing those jar files in your classpath will make catalog resolution of
the standard URIs quick and efficient.
</para>

<section>
<title>What’s in the “data” jar?</title>

<para>The data artifact (a separate <code>.jar</code> file on Java, a separate assembly on C#)
contains the following resources and a catalog that maps to local copies of them stored
in the data artifact:</para>

<xi:include href="datalist.xml"/>

<para>The data artifact is maintained separately; for the most up-to-date information
about what it contains, see <link xlink:href="https://github.com/xmlresolver/xmlresolverdata"/>
for the Java release and
<link xlink:href="https://github.com/xmlresolver/xmlresolvercsdata"/> for the C# release.
</para>

</section>

</chapter>
<chapter xml:id="using">
<info>
<title>Using an XML Resolver</title>
</info>

<para>The simplest possible thing you can do is instantiate an instance of
<classname>org.xmlresolver.XMLResolver</classname> and use it to obtain a resolver
for each of the XML parsing APIs that you are using.</para>

<informaltable frame="all">
<tgroup cols="2" colsep="1" rowsep="1">
<thead>
<row>
<entry>Call this method:</entry>
<entry>To obtain:</entry>
</row>
</thead>
<tbody>
<row>
  <entry><methodname>getEntityResolver()</methodname></entry>
  <entry>A SAX1 <interfacename>org.xml.sax.EntityResolver</interfacename></entry>
</row>
<row>
  <entry><methodname>getEntityResolver2()</methodname></entry>
  <entry>A SAX2 <interfacename>org.xml.sax.ext.EntityResolver2</interfacename></entry>
</row>
<row>
  <entry><methodname>getURIResolver()</methodname></entry>
  <entry>A JAXP <interfacename>javax.xml.transform.URIResolver</interfacename></entry>
</row>
<row>
  <entry><methodname>getLSResourceResolver()</methodname></entry>
  <entry>A W3C DOM <interfacename>org.w3c.dom.ls.LSResourceResolver</interfacename></entry>
</row>
<row>
  <entry><methodname>getXMLResolver()</methodname></entry>
  <entry>A StAX <interfacename>javax.xml.stream.XMLResolver</interfacename></entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>Another simple integration point is to instantiate
<classname>org.xmlresolver.tools.ResolvingXMLReader</classname> as your XML parser.</para>

<section xml:id="programming">
<title>Programming with the resolver</title>
<para>If you want to take more complete programmatic control of the resolver,
instantiate a resolver configuration:</para>

<programlisting language="java"
><![CDATA[XMLResolverConfiguration config
  = new XMLResolverConfiguration(propertyFiles, catalogs);]]></programlisting>

<para>Set the features as you wish:</para>

<programlisting language="java"><![CDATA[config.setFeature(ResolverFeature.LOGGER_LOG_LEVEL, "info");

if (validateCatalogs) {
    config.setFeature(ResolverFeature.CATALOG_LOADER_CLASS,
                      "org.xmlresolver.loaders.ValidatingXmlLoader");
}]]></programlisting>

<para>Then instantiate an XML Resolver:</para>

<programlisting language="java"><![CDATA[XMLResolver resolver = new XMLResolver(config);]]></programlisting>

<para>and use that resolver in your parsing and URI retrieval.</para>

<programlisting language="java"><![CDATA[myXmlReader.setEntityResolver(resolver.getEntityResolver2());]]></programlisting>

<para>For additional APIs, consult the <link xlink:href="javadoc/index.html">JavaDoc</link>.</para>
</section>

</chapter>

<chapter xml:id="configuring">
<info>
<title>Configuring an XML Resolver</title>
</info>

<para>The XML Resolver is available for both Java and .NET. By and
large, it works the same way in both environments and has similar
features. One area where differences are unavoidable is in
configuration because Java and .NET expose different mechanisms.</para>

<para>The Java XML Resolver classes use either Java system properties
or a standard Java properties file to establish an initial
environment.</para>

<para>On .NET, environment variables are used instead of system
properties and the properties file is a standard .NET configuration
file.</para>

<section xml:id="config-java">
<title>Configuring XML Resolver on Java</title>

<para>On Java, the resolver searches for a property file by looking in
the following places, in this order:</para>

<itemizedlist>
<listitem>
<para>The location identified by the <sysprop>xmlresolver.properties</sysprop> system property.
</para>
</listitem>
<listitem>
<para>The location identified by the <envar>XMLRESOLVER_PROPERTIES</envar> environment variable.
</para>
</listitem>
<listitem>
<para>A file named <filename>xmlresolver.properties</filename> on your classpath.
</para>
</listitem>
</itemizedlist>

<section xml:id="xmlresolver.properties">
<title>Example xmlresolver.properties file</title>

<para>An <filename>xmlresolver.properties</filename> file
might look like this:</para>

<programlisting>## XML Resolver properties

## Specify protocol(s) allowed for URI access
#<link linkend="xml.catalog.accessExternalDocument">access-external-document</link>=all

## Specify protocol(s) allowed for entity access
#<link linkend="xml.catalog.accessExternalEntity">access-external-entity</link>=all

## Obey oasis-xml-catalog processing instruction?
#<link linkend="xml.catalog.allowPI">allow-oasis-xml-catalog-pi</link>=true

## Always resolve resources?
#<link linkend="xml.catalog.alwaysResolve">always-resolve</link>=true

## Support catalog files in ZIP archives?
#<link linkend="xml.catalog.archivedCatalogs">archived-catalogs</link>=true

## List of additional catalog files; defaults to none
#<link linkend="xml.catalog.additions">catalog-additions</link>=

## Catalog loader class
#<link linkend="xml.catalog.catalogLoaderClass">catalog-loader-class</link>=org.xmlresolver.loaders.XmlLoader

## The initial list of catalog files; defaults to none
#<link linkend="xml.catalog.files">catalogs</link>=

## Load catalogs from the classpath?
#<link linkend="xml.catalog.classpathCatalogs">classpath-catalogs</link>=true

## Fix system identifiers on Windows?
#<link linkend="xml.catalog.fixWindowsSystemIdentifiers">fix-windows-system-identifiers</link>=false

## The logging level
#<link linkend="xml.catalog.loggerLogLevel">logger-log-level</link>=warn

## Mask jar URIs?
#<link linkend="xml.catalog.maskJarUris">mask-jar-uris</link>=true

## Merge http: and https: URI schemes?
#<link linkend="xml.catalog.mergeHttps">merge-https</link>=true

## Parse RDDL documents?
#<link linkend="xml.catalog.parseRddl">parse-rddl</link>=false

## Prefer property file values
#<link linkend="xml.catalog.preferPropertyFile">prefer-property-file</link>=false

## Preference for public or system identifiers
#<link linkend="xml.catalog.prefer">prefer</link>=public

## Support relative catalog paths
#<link linkend="relative-catalogs">relative-catalogs</link>=true

## The logger class
#<link linkend="xml.catalog.resolverLoggerClass">resolver-logger-class</link>=org.xmlresolver.logging.DefaultLogger

## The SAX parser factory class; defaults to null
#<link linkend="xml.catalog.saxParserFactoryClass">saxparserfactory-class</link>=

## Throw URI exceptions?
#<link linkend="xml.catalog.throwUriExceptions">throw-uri-exceptions</link>=false

## Use URI entries for system resolution?
#<link linkend="xml.catalog.uriForSystem">uri-for-system</link>=true</programlisting>

<para>The properites are shown with their default values.</para>

</section>
</section>

<section xml:id="config-net">
<title>Configuring XML Resolver on .NET</title>

<para>On .NET, the resolver uses the enviornment variable <envar>XMLRESOLVER_APPSETTINGS</envar>
to locate .NET properties file. The properties file can be either XML (in an
<code>XmlResolver</code> section) or JSON (in an <code>XmlResolver</code> object).</para>

<section xml:id="xmlresolver.config.xml">
<title>Example xmlresolver.config file</title>

<para>An <filename>xmlresolver.config</filename> file
might look like this:</para>

<programlisting language="xml"><![CDATA[<configuration>
  <xmlResolver relativeCatalogs="no"
               catalogs="./catalog.xml;/Users/userid/Documents/catalog.xml"
               prefer="public"
               allowOasisXmlCatalogPi="yes"
               preferPropertyFile="no"/>
</configuration>]]></programlisting>

<para>If JSON is more convenient, <!-- stranger things have happened -->
it might look like this:</para>

<programlisting language="json">{
  "XmlResolver": {
    "preferPublic": true,
    "relativeCatalogs": "false",
    "catalogs": "./catalog.xml;/Users/userid/Documents/catalog.xml",
    "prefer": "public",
    "allowOasisXmlCatalogPi": "yes",
    "preferPropertyFile": "no"
  }
}</programlisting>
</section>

</section>
</chapter>

<xi:include href="configure.xml"/>

<chapter xml:id="changelog">
<title>Change log</title>

<para>This chapter documents the significant changes in each release.</para>

<para>At the time of this writing, the 6.x release is still in testing.</para>

<revhistory>
<?db revhistory-style="list"?>
<revision>
<revnumber>6.0.20</revnumber>
<date>2025-12-31</date>
<revdescription>
<para>The 6.0.20 release is a maintance patch on the 6.x branch.</para>
<itemizedlist role="java">
<listitem>
<para>Added checks to avoid an NPE when trying to set the system identifier to the resolved URI.
</para>
</listitem>
<listitem>
<para>Substantially rewrote and simplified the resolver logger. All of
the complexity associated with categories has been removed. Most
messages previously associated with a category are simply debug level
messages.</para>
</listitem>
<listitem>
<para>As a consequence of the logger refactoring, the <code>DEFAULT_LOGGER_LOG_LEVEL</code>
is now the
<code linkend="xml.catalog.loggerLogLevel">LOGGER_LOG_LEVEL</code>.</para>
</listitem>
<listitem>
<para>Cleaned up the error handling in the catalog loader to avoid spurious error messages
about attempting to parse ZIP files (when ultimately retrieving a catalog from the ZIP file).</para>
</listitem>
</itemizedlist>
<itemizedlist role="net">
<listitem>
<para>There’s been a very substantial refactoring since the last .NET release.
</para>
</listitem>
<listitem>
<para>This version is in better alignment with the Java version and has improved C# APIs.
</para>
</listitem>
</itemizedlist>
<para>With luck, this will be the last set of test releases before the production release.</para>
</revdescription>
</revision>
<revision>
<revnumber>6.0.19</revnumber>
<date>2025-07-17</date>
<revdescription>
<para>The 6.0.19 release is a maintance patch on the 6.x branch. It fixes
<link xlink:href="https://github.com/xmlresolver/xmlresolver/issues/253">issue #253</link>;
RDDL parsing always uses the resolved resource, not the original URI.
RDDL parsing is also disabled now, by default. If you’re using RDDL, make sure you
enable it in your configuration.
</para>
<para>The caching feature is not present in version 6.x of the resolver, but
there were several dangling references to it. Those have also been removed.
</para>
</revdescription>
</revision>
<revision>
<revnumber>6.0.18</revnumber>
<date>2025-06-30</date>
<revdescription>
<para>The 6.0.18 release is a maintance patch on the 6.x branch. It fixes
<link xlink:href="https://github.com/xmlresolver/xmlresolver/issues/250">issue #250</link>;
Xerces is no longer an implementation dependency.
</para>
</revdescription>
</revision>
<revision>
<revnumber>6.0.17</revnumber>
<date>2025-05-19</date>
<revdescription>
<para>The 6.0.17 release is a maintance patch on the 6.x branch. It fixes
<link xlink:href="https://github.com/xmlresolver/xmlresolver/issues/248">issue #248</link>.
</para>
</revdescription>
</revision>
<revision>
<revnumber>6.0.16</revnumber>
<date>2025-05-17</date>
<revdescription>
<para>This is an interface change. It adds a <code>copy()</code> method to the
<interfacename>ResolverConfiguration</interfacename> interface and removes the
then redundant copy constructor for
<classname>XMLResolverConfiguration</classname>. There are also a few JavaDoc fixes.
</para>
</revdescription>
</revision>
<revision>
<revnumber>6.0.15</revnumber>
<date>2025-05-13</date>
<revdescription>
<para>Fixed <link xlink:href="https://github.com/xmlresolver/xmlresolver/issues/242">#242</link>.
Rewrite entries are now concatenated with, not resolved against, the rewrite prefix.
</para>
</revdescription>
</revision>
<revision>
<revnumber>5.3.3</revnumber>
<date>2025-05-13</date>
<revdescription>
<para>The 5.3.3 release is a maintance patch on the 5.x branch. It fixes
<link xlink:href="https://github.com/xmlresolver/xmlresolver/issues/242">issue #242</link>.
Rewrite entries are now concatenated with, not resolved against, the rewrite prefix.
</para>
</revdescription>
</revision>
<revision>
<revnumber>5.3.2</revnumber>
<date>2025-05-06</date>
<revdescription>
<para>The 5.3.2 release is a maintance patch on the 5.x branch. It fixes
a bug where catalog file names that include drive letters on Windows were
not handled correctly. This bug does not effect 6.0.14.
</para>
</revdescription>
</revision>
<revision>
<revnumber>5.3.1</revnumber>
<date>2025-04-24</date>
<revdescription>
<para>The 5.3.1 release is a maintance patch on the 5.x branch. It borrows
some code from the 6.x branch to remove the dependencies on the Apache HttpComponents
libraries and a compile time dependency on Xerces.</para>
</revdescription>
</revision>
<revision>
<revnumber>6.0.14</revnumber>
<date>2025-03-13</date>
<revdescription>
<itemizedlist>
<listitem>
<para>Fixed <link xlink:href="https://github.com/xmlresolver/xmlresolver/issues/229">#229</link>.
The interaction between the “always resolve” feature and namespace URI lookup
had the unfortunate consequence of returning the (almost always incorrect)
document at the namespace URI as the resource. I’ve adjusted the API so that
this is no longer the case. It’s now possible to configure “always resolve” on
a per-request basis. This changes an interface so it’s not binary backwards
compatible with previous 6.x releases.</para>
</listitem>
<listitem>
<para>Fixed <link xlink:href="https://github.com/xmlresolver/xmlresolver/issues/230">#230</link>.
When “always resolve” returned a resource, that URI wasn’t being logged which
lead to a confusing log trace.</para>
</listitem>
</itemizedlist>
</revdescription>
</revision>
<revision>
<revnumber>6.0.13</revnumber>
<date>2025-03-10</date>
<revdescription>
<para>Changed the API so that an attempt to read a scheme that’s forbidden
(by <code>ResolverFeature.ACCESS_EXTERNAL_ENTITY</code> or
<code>ResolverFeature.ACCESS_EXTERNAL_DOCUMENT</code>) raises an
<exceptionname>IllegalArgumentException</exceptionname> instead of returning
<code>null</code>.</para>
<para>Generally, the XML Resolver tries to avoid throwing exceptions, but in this
case failing to do so opens a security vulnerability. Returning <code>null</code> often
signals the underlying parser to simply load the resource with the original URI. This 
circumvents the attempt to limit access.</para>
</revdescription>
</revision>
<revision>
<revnumber>5.3.0</revnumber>
<date>2025-03-10</date>
<revdescription>
<para>The 5.3.0 release is a maintance patch on the 5.x branch to provide
the security fix for foribidden URIs there as well.</para>
</revdescription>
</revision>
<revision>
<revnumber>6.0.12</revnumber>
<date>2025-01-24</date>
<revdescription>
<itemizedlist>
<listitem><para>Reworked the API to use interfaces for <interfacename>ResourceRequest</interfacename> and
<interfacename>ResourceResponse</interfacename>. This makes writing a schema handler easier. This is a
backwards incompatible change if you were directly accessing those objects.
You have to access the <classname>ResourceRequestImpl</classname> and
<classname>ResourceResponseImpl</classname>
instead. On the plus side, the setters are now public on those methods.
</para></listitem>
<listitem><para>Added code that attempts to detect a Windows path (C:\path) passed as a
catalog or property file name and avoid accidentally constructing a URI with
the scheme “C”.
</para></listitem>
</itemizedlist>
</revdescription>
</revision>
<revision>
<revnumber>6.0.11</revnumber>
<date>2024-10-28</date>
<revdescription>
<para>This version introduces a new API for registering a scheme resolver. This will
allow a resolver to be configured, for example, to handle custom URI schemes as
are sometimes found in products.</para>
</revdescription>
</revision>
<revision>
<revnumber>6.0.10</revnumber>
<date>2024-09-22</date>
<revdescription>
<para>Fixed a bug where the resolver didn’t set the system identifier of the source.
This closes <link xlink:href="https://github.com/xmlresolver/xmlresolver/issues/211">issue 211</link>.
</para>
</revdescription>
</revision>
<revision>
<revnumber>6.0.9</revnumber>
<date>2024-08-19</date>
<revdescription>
<para>Fixed a bug where the stream opened to read resolver properties might be
unclosed. 
This closes <link xlink:href="https://github.com/xmlresolver/xmlresolver/issues/208">issue 208</link>.
</para>
</revdescription>
</revision>
<revision>
<revnumber>6.0.8</revnumber>
<date>2024-08-07</date>
<revdescription>
<para>This release restores the <code>NamespaceResolver</code> API. This API is
deprecated, but improves backwards compatibility with version 5.x.
</para>
</revdescription>
</revision>
<revision>
<revnumber>6.0.7</revnumber>
<date>2024-08-07</date>
<revdescription>
<para>This release removes two dependencies: the SLF4J API and the
Apache HTTP Client API. This has no user-visible changes in the API, but makes
version 6.x of the resolver a drop-in replacement for version 5.x in most cases.</para>
</revdescription>
</revision>
<revision>
<revnumber>6.0.6</revnumber>
<date>2024-08-06</date>
<revdescription>
<para>The following changes are included:</para>
<variablelist>
<varlistentry>
<term>Improvements to support for UNC paths</term>
<listitem>
<para>Documents and catalogs that use Windows UNC paths are better supported
if the <link linkend="xml.catalog.fixWindowsSystemIdentifiers">FIX_WINDOWS_SYSTEM_IDENTIFIERS</link>
feature is enabled.</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Support for Java 21</term>
<listitem>
<para>The build still produces class (and jar) files that will work with any
version of Java back to Java 8. However, the build itself now uses Java 21.
This closes <link xlink:href="https://github.com/xmlresolver/xmlresolver/issues/173">issue 173</link>.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Refactor the SAX entity resolvers</term>
<listitem>
<para>The SAX <code>EntityResolver</code> and <code>EntityResolver2</code> interfaces
are now implemented on separate objects. 
This closes <link xlink:href="https://github.com/xmlresolver/xmlresolver/issues/183">issue 183</link>.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Fix namespace-based lookup in the DOM</term>
<listitem>
<para>The <code>LSResourceAdapter</code> API used when resolving documents
for the DOM did not correctly handle XML Schema validation. It was failing
to lookup based on the namespace.
This closes <link xlink:href="https://github.com/xmlresolver/xmlresolver/issues/180">issue 180</link>.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Improved support for concurrency</term>
<listitem>
<para>The catalog lookup code was not sufficiently careful about multi-threaded
access. My thanks to <link xlink:href="https://github.com/JFK-DXML">JFK-DXML</link> for
the patch.
This closes <link xlink:href="https://github.com/xmlresolver/xmlresolver/issues/182">issue 182</link>.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Reworked the FIX_WINDOWS_SYSTEM_IDENTIFIERS feature</term>
<listitem>
<para>This feature now applies irrespective of platform. This will enable Windows
documents and catalogs to work correctly even on non-Windows systems.
This closes <link xlink:href="https://github.com/xmlresolver/xmlresolver/issues/184">issue 184</link>.
</para>
</listitem>
</varlistentry>
</variablelist>

<para>A number of smaller issues (testing and build system issues and issues not
expected to be user visible) have also been corrected. See the commit log for more details.
</para>
</revdescription>
</revision>
<revision>
<revnumber>6.0.5</revnumber>
<date>2024-07-22</date>
<revdescription>
<para>Apparently version 6.0.5 was never released.</para>
</revdescription>
</revision>
</revhistory>
</chapter>

<chapter xml:id="seealso">
<title>See also</title>

<itemizedlist>
<listitem>
<para>Absent more complete information here, most of
<link xlink:href="https://xerces.apache.org/xml-commons/components/resolver/resolver-article.html">XML
Entity and URI Resolvers</link> is still relevant.</para>
</listitem>
<listitem>
<para><link xlink:href="https://xmlcatalogs.org">XML Catalogs</link>
</para>
</listitem>
</itemizedlist>

</chapter>

<index xml:id="system-properties-index" type="sysprop">
<title>System properties index</title>
</index>

<index xml:id="property-file-properties-index" type="fprop">
<title>File properties index</title>
</index>

<index xml:id="envar-index" type="envar">
<title>Environment variables index</title>
</index>

<index xml:id="constant-index" type="constant">
<title>Constants index</title>
</index>

<index xml:id="api-index" type="code">
<title>API index</title>
<para>This index only includes the interface items mentioned in the
text. For additional APIs, consult the <link
xlink:href="javadoc/index.html">JavaDoc</link>.
</para>
</index>

</book>
